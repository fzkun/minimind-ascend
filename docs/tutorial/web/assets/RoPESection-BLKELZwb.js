import{u as E,r as N,j as t}from"./index-DB782DBc.js";import{C as R,S as B}from"./SourcePanel-BwVAQ71f.js";import{u as w}from"./useCanvas-BahyMyhc.js";import{M as y}from"./constants-BXPCUJh7.js";function C(){const{isDark:e}=E(),[$,q]=N.useState(0),T=w((o,m)=>{W(o,m,0,$,e)},[e,$],250,250),v=w((o,m)=>{W(o,m,31,$,e)},[e,$],250,250),S=w((o,m,j)=>{o.fillStyle=e?"#1e293b":"#f8f8f8",o.fillRect(0,0,m,j);const s=50,c=20,i=30,d=40,p=m-s-c,r=j-i-d,g=64,a=[];for(let f=0;f<=g;f++){let _=0;for(let b=0;b<y.head_dim/2;b++){const P=1/Math.pow(y.rope_base,2*b/y.head_dim);_+=Math.cos(f*P)}_/=y.head_dim/2,a.push(_)}const n=Math.max(...a.map(Math.abs)),h=e?"#e2e8f0":"#1a1a2e",l=e?"#64748b":"#aaa";o.strokeStyle=l,o.lineWidth=1,o.beginPath(),o.moveTo(s,i),o.lineTo(s,i+r),o.lineTo(s+p,i+r),o.stroke(),o.fillStyle=h,o.font="10px monospace",o.textAlign="right",o.fillText("1.0",s-5,i+5),o.fillText("0",s-5,i+r/2+3),o.fillText("-1.0",s-5,i+r+3),o.textAlign="center";for(let f=0;f<=g;f+=16){const _=s+f/g*p;o.fillText(String(f),_,i+r+15)}o.fillText("相对距离 |m-n|",s+p/2,j-5),o.save(),o.translate(12,i+r/2),o.rotate(-Math.PI/2),o.fillText("点积 (归一化)",0,0),o.restore(),o.strokeStyle=l,o.lineWidth=.5,o.setLineDash([3,3]);const M=i+r/2;o.beginPath(),o.moveTo(s,M),o.lineTo(s+p,M),o.stroke(),o.setLineDash([]);const x=e?"#818cf8":"#4f46e5";o.strokeStyle=x,o.lineWidth=2,o.beginPath();for(let f=0;f<=g;f++){const _=s+f/g*p,b=i+r/2-a[f]/n*(r/2);f===0?o.moveTo(_,b):o.lineTo(_,b)}o.stroke(),o.fillStyle=h,o.font="11px sans-serif",o.textAlign="left",o.fillText("RoPE Q·K 点积随相对距离衰减（维度平均）",s,18)},[e],500,200),u=N.useMemo(()=>{const o=e?"#e2e8f0":"#1a1a2e",m=e?"#94a3b8":"#555",j=e?"#34d399":"#10b981",s=e?"#fbbf24":"#f59e0b",c=e?"#f87171":"#ef4444",i=e?"#1e293b":"#f0f0f0",d=y.head_dim,p=x=>d*Math.log(y.yarn_orig_max/(x*2*Math.PI))/(2*Math.log(y.rope_base)),r=Math.max(Math.floor(p(y.yarn_beta_fast)),0),g=Math.min(Math.ceil(p(y.yarn_beta_slow)),d/2-1),a=60,n=30,h=520,l=140;let M="";for(let x=0;x<d/2;x++){const f=Math.max(0,Math.min(1,(x-r)/Math.max(g-r,.001))),_=1-f+f/y.yarn_factor,b=a+x/(d/2)*h,P=h/(d/2)-.5,z=_*l;let k;f<=0?k=j:f>=1?k=c:k=s,M+=`<rect x="${b}" y="${n+l-z}" width="${Math.max(P,1)}" height="${z}" fill="${k}" opacity="0.7"/>`}return`
      <rect x="${a}" y="${n}" width="${h}" height="${l}" fill="${i}" rx="4"/>
      ${M}
      <line x1="${a}" y1="${n+l}" x2="${a+h}" y2="${n+l}" stroke="${m}" stroke-width="1"/>
      <line x1="${a}" y1="${n}" x2="${a}" y2="${n+l}" stroke="${m}" stroke-width="1"/>
      <text x="${a+h/2}" y="${n+l+30}" text-anchor="middle" fill="${o}" font-size="11">频率维度 i (0 ~ ${d/2-1})</text>
      <text x="${a-5}" y="${n+5}" text-anchor="end" fill="${o}" font-size="10">1.0</text>
      <text x="${a-5}" y="${n+l}" text-anchor="end" fill="${o}" font-size="10">${(1/y.yarn_factor).toFixed(3)}</text>
      <text x="10" y="${n+l/2}" text-anchor="middle" fill="${o}" font-size="10" transform="rotate(-90, 10, ${n+l/2})">缩放系数</text>
      <text x="${a+h/2}" y="18" text-anchor="middle" fill="${o}" font-size="12" font-weight="bold">YaRN: f'(i) = f(i) × ((1-γ) + γ/s)，s=${y.yarn_factor}</text>
      <line x1="${a+r/(d/2)*h}" y1="${n}" x2="${a+r/(d/2)*h}" y2="${n+l}" stroke="${m}" stroke-width="1" stroke-dasharray="3,3"/>
      <line x1="${a+g/(d/2)*h}" y1="${n}" x2="${a+g/(d/2)*h}" y2="${n+l}" stroke="${m}" stroke-width="1" stroke-dasharray="3,3"/>
      <text x="${a+r/(d/2)*h}" y="${n+l+15}" text-anchor="middle" fill="${m}" font-size="9">low=${r}</text>
      <text x="${a+g/(d/2)*h}" y="${n+l+15}" text-anchor="middle" fill="${m}" font-size="9">high=${g}</text>
    `},[e]);return t.jsxs(t.Fragment,{children:[t.jsx("h2",{children:"4. RoPE 位置编码"}),t.jsxs("p",{className:"desc",children:["旋转位置编码 (RoPE) 把位置信息注入到 Q/K 向量中，让 attention score 自然反映 token 之间的相对距离。 核心操作是对 Q/K 的每对相邻维度做旋转，角度由 ",t.jsx("code",{children:"rope_theta=1e6"})," 和位置索引决定。 MiniMind 还支持 YaRN 频率缩放，实现长上下文外推。",t.jsx("br",{}),t.jsxs("small",{style:{color:"var(--fg2)"},children:["关联源码：",t.jsx("code",{children:"model/model_minimind.py:109"})," ",t.jsx("code",{children:"def precompute_freqs_cis()"})," | ",t.jsx("code",{children:":105"})," ",t.jsx("code",{children:"def forward"})," (apply_rotary_emb)"]})]}),t.jsxs(R,{title:"旋转向量动画",children:[t.jsx("p",{style:{marginBottom:10,fontSize:"0.9rem",color:"var(--fg2)"},children:"RoPE 将 Q/K 向量的 64 个维度两两配对成 32 组，每组视为一个 2D 向量并旋转 θ 角度。 旋转角 θ = position × freq[i]，其中 freq[i] = 1/(base^(2i/d))。低维度组频率高（旋转快），高维度组频率低（旋转慢）。"}),t.jsx("p",{style:{marginBottom:10,fontSize:"0.9rem",color:"var(--fg2)"},children:"拖动下方滑块改变 position 值，观察两个频道的向量旋转情况：左图是频道 0（高频，每步旋转角度大）， 右图是频道 31（低频，需要很大的 position 差异才能看到明显旋转）。半透明小点表示历史位置的轨迹，绿色虚线是 position=0 时的初始方向。"}),t.jsxs("div",{className:"viz-grid",children:[t.jsxs("div",{children:[t.jsx("div",{className:"label",children:"频道 0（高频，快速旋转）"}),t.jsx("canvas",{ref:T})]}),t.jsxs("div",{children:[t.jsx("div",{className:"label",children:"频道 31（低频，缓慢旋转）"}),t.jsx("canvas",{ref:v})]})]}),t.jsxs("div",{style:{marginTop:10},children:[t.jsxs("div",{className:"label",children:["位置 position = ",t.jsx("span",{className:"value",children:$})]}),t.jsx("input",{type:"range",min:"0",max:"127",step:"1",value:$,onChange:o=>q(parseInt(o.target.value))})]}),t.jsx(B,{title:"对照源码：model/model_minimind.py:109-137",code:`def precompute_freqs_cis(dim, end=32768, rope_base=1e6, rope_scaling=None):
    """预计算所有位置的旋转频率 cos/sin，模型初始化时调用一次"""
    # 计算每个维度对的基础频率：freq[i] = 1 / (base ^ (2i/dim))
    # dim=64 时产生 32 个频率，从高频 (i=0) 到低频 (i=31)
    freqs = 1.0 / (rope_base ** (torch.arange(0, dim, 2)[:dim//2].float() / dim))
    # t = [0, 1, 2, ..., end-1]，代表所有可能的位置
    t = torch.arange(end)
    # 外积得到旋转角矩阵：theta[pos][i] = pos * freq[i]
    freqs = torch.outer(t, freqs)  # [seq_len, dim/2]
    # 复制一份拼接，使 cos/sin 维度与 head_dim 对齐（方便后续逐元素相乘）
    freqs_cos = torch.cat([cos(freqs), cos(freqs)], dim=-1)  # [seq_len, dim]
    freqs_sin = torch.cat([sin(freqs), sin(freqs)], dim=-1)  # [seq_len, dim]
    return freqs_cos, freqs_sin

def apply_rotary_pos_emb(q, k, cos, sin):
    """将旋转位置编码应用到 Q 和 K（V 不需要位置信息）"""
    def rotate_half(x):
        # 将向量拆为前后两半并交换，配合负号实现 2D 旋转矩阵的效果
        # [x0, x1, ..., x31, x32, ..., x63] → [-x32, ..., -x63, x0, ..., x31]
        return torch.cat((-x[..., x.shape[-1]//2:], x[..., :x.shape[-1]//2]), dim=-1)
    # 旋转公式：q' = q * cos(θ) + rotate_half(q) * sin(θ)
    # 这等价于对每对 (q_{2i}, q_{2i+1}) 做 2D 旋转矩阵运算
    q_embed = q * cos + rotate_half(q) * sin
    k_embed = k * cos + rotate_half(k) * sin
    return q_embed, k_embed`})]}),t.jsxs(R,{title:"相对位置点积",children:[t.jsx("p",{style:{marginBottom:10,fontSize:"0.9rem",color:"var(--fg2)"},children:"RoPE 最关键的数学性质：对位置 m 的 Q 和位置 n 的 K 施加旋转后，它们的点积 Q_m · K_n 只取决于相对距离 |m-n|， 与绝对位置无关。这使模型天然具备处理不同长度序列的能力。"}),t.jsx("p",{style:{marginBottom:10,fontSize:"0.9rem",color:"var(--fg2)"},children:"下图展示了归一化后的平均点积随相对距离的变化曲线。可以观察到：距离越近，点积越大（注意力越强）； 距离越远，点积衰减并振荡趋近于零。这种自然的远近衰减正是注意力机制所需要的。"}),t.jsx("canvas",{ref:S})]}),t.jsxs(R,{title:"YaRN 频率缩放",children:[t.jsx("p",{style:{marginBottom:10,fontSize:"0.9rem",color:"var(--fg2)"},children:"当推理长度超过训练长度时，高频维度的旋转角过大会导致注意力崩溃。YaRN 通过对频率维度分区缩放来解决这个问题："}),t.jsx("p",{style:{marginBottom:10,fontSize:"0.9rem",color:"var(--fg2)"},children:"绿色区域（高频）：这些维度在训练范围内已经充分旋转，不需要缩放，保持原始频率。 橙色区域（过渡带）：通过线性插值 γ(i) 在不缩放和完全缩放之间平滑过渡。 红色区域（低频）：这些维度旋转最慢，外推时影响最大，频率除以 factor=16 进行压缩。 MiniMind 通过这种方式将上下文窗口从 2048 扩展到 32768 token。"}),t.jsx("svg",{width:"100%",height:220,viewBox:"0 0 600 220",dangerouslySetInnerHTML:{__html:u}}),t.jsxs("div",{style:{marginTop:8,display:"flex",gap:16,flexWrap:"wrap",fontSize:"0.85rem"},children:[t.jsx("span",{style:{color:"var(--green)"},children:"■ 高频（不缩放）"}),t.jsx("span",{style:{color:"var(--orange)"},children:"■ 过渡带（线性插值）"}),t.jsx("span",{style:{color:"var(--red)"},children:"■ 低频（÷16 缩放）"})]})]})]})}function W(e,$,q,T,v){const S=v?"#1e293b":"#f8f8f8",u=v?"#e2e8f0":"#1a1a2e",o=v?"#475569":"#ddd",m=v?"#818cf8":"#4f46e5",j=v?"#34d399":"#10b981";e.fillStyle=S,e.fillRect(0,0,$,$);const s=$/2,c=$/2,i=90;e.strokeStyle=o,e.lineWidth=.5,e.beginPath(),e.moveTo(s-i-20,c),e.lineTo(s+i+20,c),e.stroke(),e.beginPath(),e.moveTo(s,c-i-20),e.lineTo(s,c+i+20),e.stroke(),e.beginPath(),e.arc(s,c,i,0,Math.PI*2),e.stroke();const d=1/Math.pow(y.rope_base,2*q/y.head_dim),p=T*d;e.globalAlpha=.15;for(let n=0;n<T;n++){const h=n*d,l=s+i*Math.cos(h),M=c-i*Math.sin(h);e.fillStyle=m,e.beginPath(),e.arc(l,M,2,0,Math.PI*2),e.fill()}e.globalAlpha=1;const r=s+i*Math.cos(p),g=c-i*Math.sin(p);e.strokeStyle=m,e.lineWidth=2.5,e.beginPath(),e.moveTo(s,c),e.lineTo(r,g),e.stroke(),e.fillStyle=m,e.beginPath(),e.arc(r,g,5,0,Math.PI*2),e.fill();const a=s+i;e.strokeStyle=j,e.lineWidth=1.5,e.setLineDash([4,3]),e.beginPath(),e.moveTo(s,c),e.lineTo(a,c),e.stroke(),e.setLineDash([]),e.fillStyle=u,e.font="11px monospace",e.textAlign="left",e.fillText(`freq[${q}] = ${d.toExponential(2)}`,8,18),e.fillText(`θ = pos × freq = ${p.toFixed(3)}`,8,33),e.fillText(`cos(θ) = ${Math.cos(p).toFixed(3)}`,8,$-20),e.fillText(`sin(θ) = ${Math.sin(p).toFixed(3)}`,8,$-6)}export{C as default};
